<!doctype html>
<html>
	<head>
		<title>{{ title }} | Talos App</title>
		<style>
			body {
				font-family: Arial, sans-serif;
				margin: 20px;
				max-width: 800px;
				margin-left: auto;
				margin-right: auto;
			}
			h1 {
				color: #333;
			}
			video {
				width: 100%;
				max-width: 640px;
				border: 2px solid #ccc;
				border-radius: 4px;
				margin: 20px 0;
				background-color: #000;
			}
			.controls {
				margin: 20px 0;
				display: flex;
				gap: 10px;
				flex-wrap: wrap;
				align-items: center;
			}
			select {
				padding: 8px 12px;
				font-size: 14px;
				border: 1px solid #ccc;
				border-radius: 4px;
			}
			button {
				padding: 8px 16px;
				font-size: 14px;
				border: none;
				border-radius: 4px;
				cursor: pointer;
				background-color: #007bff;
				color: white;
				transition: background-color 0.2s;
			}
			button:hover:not(:disabled) {
				background-color: #0056b3;
			}
			button:disabled {
				background-color: #ccc;
				cursor: not-allowed;
			}
			#status {
				padding: 12px;
				border-radius: 4px;
				margin-top: 20px;
				display: none;
				font-weight: bold;
			}
			#status.connected {
				background-color: #d4edda;
				color: #155724;
				border: 1px solid #c3e6cb;
				display: block;
			}
			#status.connecting {
				background-color: #fff3cd;
				color: #856404;
				border: 1px solid #ffeaa7;
				display: block;
			}
			#status.error {
				background-color: #f8d7da;
				color: #721c24;
				border: 1px solid #f5c6cb;
				display: block;
			}
		</style>
	</head>
	<body>
		<h1>{{ title }}</h1>

		<div class="controls">
			<label for="connection-select">Connection:</label>
			<select id="connection-select" onchange="changeConnection()">
				<option value="_auto_">Auto</option>
				{% for conn in connections %}
				<option
					value="{{ conn }}"
					{%
					if
					conn==active_connection
					%}selected{%
					endif
					%}
				>
					{{ conn }}
				</option>
				{% endfor %}
			</select>
		</div>

		<!-- WebRTC Video Element -->
		<video id="video" autoplay playsinline></video>

		<div class="controls">
			<button id="connect-btn" onclick="startConnection()">Connect</button>
			<button id="disconnect-btn" onclick="stopConnection()" disabled>
				Disconnect
			</button>
		</div>

		<div id="status"></div>

		<script>
			let pc = null;
			let peerId = null;
			const videoElement = document.getElementById('video');
			const connectBtn = document.getElementById('connect-btn');
			const disconnectBtn = document.getElementById('disconnect-btn');
			const statusDiv = document.getElementById('status');
			const connectionSelect = document.getElementById('connection-select');

			function setStatus(message, type) {
				statusDiv.textContent = message;
				statusDiv.className = type;
			}

			function changeConnection() {
				if (pc) {
					stopConnection();
				}
				const hostname = connectionSelect.value;
				if (hostname === '_auto_') {
					window.location.href = '/';
				} else {
					window.location.href = `/app/${hostname}`;
				}
			}

			async function startConnection() {
				setStatus('Connecting...', 'connecting');
				connectBtn.disabled = true;
				disconnectBtn.disabled = false;

				try {
					// Create RTCPeerConnection with STUN server for NAT traversal
					pc = new RTCPeerConnection({
						iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }],
					});

					// Attach incoming video track to the video element
					pc.ontrack = (event) => {
						videoElement.srcObject = event.streams[0];
					};

					// Buffer to store ICE candidates until we have peerId
					const iceCandidateBuffer = [];

					// Send ICE candidates to server (buffer until we have peerId)
					pc.onicecandidate = async (event) => {
						if (event.candidate) {
							const candidateData = {
								candidate: event.candidate.candidate,
								sdpMid: event.candidate.sdpMid,
								sdpMLineIndex: event.candidate.sdpMLineIndex,
							};

							if (peerId) {
								// If we have peerId, send immediately
								await fetch('/ice', {
									method: 'POST',
									headers: { 'Content-Type': 'application/json' },
									body: JSON.stringify({
										peer_id: peerId,
										...candidateData,
									}),
								});
							} else {
								// Buffer candidates until we get peerId
								iceCandidateBuffer.push(candidateData);
							}
						}
					};

					// Add transceiver to request video FROM server (receive only)
					pc.addTransceiver('video', { direction: 'recvonly' });

					// Determine track type and hostname
					const isDefault = window.location.pathname === '/';
					const trackType = isDefault ? 'default' : 'hostname';
					const hostname = document.getElementById('connection-select').value;

					// Create SDP offer
					const offer = await pc.createOffer();
					await pc.setLocalDescription(offer);

					// Send offer to signaling server (/offer endpoint)
					const response = await fetch('/offer', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							sdp: offer.sdp,
							type: 'offer',
							track_type: trackType,
							hostname: trackType === 'hostname' ? hostname : null,
						}),
					});

					if (!response.ok) {
						throw new Error(`Server error: ${response.statusText}`);
					}

					// Receive answer from server
					const answer = await response.json();
					peerId = answer.peer_id;

					// Send buffered ICE candidates now that we have peerId
					for (const candidateData of iceCandidateBuffer) {
						await fetch('/ice', {
							method: 'POST',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify({
								peer_id: peerId,
								...candidateData,
							}),
						});
					}
					iceCandidateBuffer.length = 0;

					// Set remote description (server's answer)
					await pc.setRemoteDescription(
						new RTCSessionDescription({
							type: 'answer',
							sdp: answer.sdp,
						}),
					);

					setStatus('Connected via WebRTC', 'connected');
				} catch (error) {
					console.error('WebRTC connection error:', error);
					setStatus(`Error: ${error.message}`, 'error');
					connectBtn.disabled = false;
					disconnectBtn.disabled = true;
					if (pc) {
						await pc.close();
						pc = null;
					}
				}
			}

			async function stopConnection() {
				try {
					if (peerId) {
						await fetch(`/offer/${peerId}`, { method: 'DELETE' });
					}
					if (pc) {
						await pc.close();
						pc = null;
					}
					videoElement.srcObject = null;
					statusDiv.className = '';
					setStatus('', '');
					connectBtn.disabled = false;
					disconnectBtn.disabled = true;
				} catch (error) {
					console.error('Disconnect error:', error);
					setStatus(`Error: ${error.message}`, 'error');
				}
			}

			// Auto-connect on page load
			window.addEventListener('load', () => {
				startConnection();
			});

			// Clean up on page unload
			window.addEventListener('beforeunload', () => {
				stopConnection();
			});
		</script>
	</body>
</html>
